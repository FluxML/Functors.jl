var documenterSearchIndex = {"docs":
[{"location":"#Functors.jl","page":"Home","title":"Functors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Functors.@functor\nFunctors.fmap\nFunctors.children\nFunctors.isleaf\nFunctors.fcollect\nFunctors.@functor","category":"page"},{"location":"#Functors.fmap","page":"Home","title":"Functors.fmap","text":"fmap(f, x; exclude = isleaf, walk = Functors._default_walk)\n\nA structure and type preserving map that works for all functors.\n\nBy default, traverses x recursively using functor and transforms every leaf node identified by exclude with f.\n\nFor advanced customization of the traversal behaviour, pass a custom walk function of the form (f', xs) -> .... This function walks (maps) over xs calling the continuation f' to continue traversal.\n\nExamples\n\njulia> struct Foo; x; y; end\n\njulia> @functor Foo\n\njulia> struct Bar; x; end\n\njulia> @functor Bar\n\njulia> m = Foo(Bar([1,2,3]), (4, 5));\n\njulia> fmap(x -> 2x, m)\nFoo(Bar([2, 4, 6]), (8, 10))\n\njulia> fmap(string, m)\nFoo(Bar(\"[1, 2, 3]\"), (\"4\", \"5\"))\n\njulia> fmap(string, m, exclude = v -> v isa Bar)\nFoo(\"Bar([1, 2, 3])\", (4, 5))\n\njulia> fmap(x -> 2x, m, walk=(f, x) -> x isa Bar ? x : Functors._default_walk(f, x))\nFoo(Bar([1, 2, 3]), (8, 10))\n\n\n\n\n\n","category":"function"},{"location":"#Functors.children","page":"Home","title":"Functors.children","text":"children(x)\n\nReturn the children of x as defined by functor. Equivalent to functor(x)[1].\n\n\n\n\n\n","category":"function"},{"location":"#Functors.isleaf","page":"Home","title":"Functors.isleaf","text":"isleaf(x)\n\nReturn true if x has no children according to functor.\n\n\n\n\n\n","category":"function"},{"location":"#Functors.fcollect","page":"Home","title":"Functors.fcollect","text":"fcollect(x; exclude = v -> false)\n\nTraverse x by recursing each child of x as defined by functor and collecting the results into a flat array.\n\nDoesn't recurse inside branches rooted at nodes v for which exclude(v) == true. In such cases, the root v is also excluded from the result. By default, exclude always yields false.\n\nSee also children.\n\nExamples\n\njulia> struct Foo; x; y; end\n\njulia> @functor Foo\n\njulia> struct Bar; x; end\n\njulia> @functor Bar\n\njulia> struct NoChildren; x; y; end\n\njulia> m = Foo(Bar([1,2,3]), NoChildren(:a, :b))\nFoo(Bar([1, 2, 3]), NoChildren(:a, :b))\n\njulia> fcollect(m)\n4-element Vector{Any}:\n Foo(Bar([1, 2, 3]), NoChildren(:a, :b))\n Bar([1, 2, 3])\n [1, 2, 3]\n NoChildren(:a, :b)\n\njulia> fcollect(m, exclude = v -> v isa Bar)\n2-element Vector{Any}:\n Foo(Bar([1, 2, 3]), NoChildren(:a, :b))\n NoChildren(:a, :b)\n\njulia> fcollect(m, exclude = v -> Functors.isleaf(v))\n2-element Vector{Any}:\n Foo(Bar([1, 2, 3]), NoChildren(:a, :b))\n Bar([1, 2, 3])\n\n\n\n\n\n","category":"function"}]
}
