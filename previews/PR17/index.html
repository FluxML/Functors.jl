<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Functors.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-36890222-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-36890222-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Functors.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FluxML/Functors.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functors.jl"><a class="docs-heading-anchor" href="#Functors.jl">Functors.jl</a><a id="Functors.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Functors.jl" title="Permalink"></a></h1><p>Functors.jl provides a set of tools to represent <a href="https://en.wikipedia.org/wiki/Functor_(functional_programming)">functors</a>. Functors are a powerful means to apply functions to generic objects without changing their structure.</p><p>Functors can be used in a variety of ways. One is to traverse a complicated or nested structure as a tree and apply a function <code>f</code> to its fields.</p><p>For large models it can be cumbersome or inefficient to work with parameters as one big, flat vector, and structs help manage complexity; but you also want to easily operate over all parameters at once, e.g. for changing precision or applying an optimiser update step.</p><div class="admonition is-warning"><header class="admonition-header">Not everything should be a functor!</header><div class="admonition-body"><p>Due to its generic nature it is very attractive to mark several structures as <a href="@ref"><code>@functor</code></a> when it may not be quite safe to do so. Typically, since any function <code>f</code> is applied to the leaves of the tree, but it is possible for some functions to require dispatching on the specific type of the fields causing some methods to be missed entirely. Examples of this include element types of arrays which have typically have their own mathematical operations defined.</p></div></div><p>When one marks a structure as <a href="@ref"><code>@functor</code></a> it means that Functors.jl is allowed to look into the fields of the instances of the struct and modify them. This is achieved through <a href="#Functors.fmap"><code>Functors.fmap</code></a>.</p><p>The workhorse of fmap is actually a lower level function, functor:</p><pre><code class="language-julia-repl">julia&gt; using Functors

julia&gt; struct Foo
         x
         y
       end

julia&gt; @functor Foo

julia&gt; foo = Foo(1, [1, 2, 3]) # notice all the elements are integers

julia&gt; xs, re = Functors.functor(foo)
((x = 1, y = [1, 2, 3]), var&quot;#21#22&quot;())

julia&gt; re(map(float, xs)) # element types have been switched out for floating point numbers
Foo(1.0, [1.0, 2.0, 3.0])</code></pre><p><code>functor</code> returns the parts of the object that can be inspected, as well as a reconstruction function (shown as <code>re</code>) that takes those values and restructures them back into an object of the original type.</p><p>To include only certain fields of a struct, one can pass a tuple of field names to <a href="@ref"><code>@functor</code></a>:</p><pre><code class="language-julia-repl">julia&gt; struct Baz
         x
         y
       end

julia&gt; @functor Baz (x,)

julia&gt; model = Baz(1, 2)
Baz(1, 2)

julia&gt; fmap(float, model)
Baz(1.0, 2)</code></pre><p>Any field not in the list will be passed through as-is during reconstruction. This is done by invoking the default constructor, so structs that define custom inner constructors are expected to provide one that acts like the default.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Functors.@functor</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Functors.fmap" href="#Functors.fmap"><code>Functors.fmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fmap(f, x; exclude = isleaf, walk = Functors._default_walk)</code></pre><p>A structure and type preserving <code>map</code> that works for all <a href="@ref"><code>functor</code></a>s.</p><p>By default, traverses <code>x</code> recursively using <a href="@ref"><code>functor</code></a> and transforms every leaf node identified by <code>exclude</code> with <code>f</code>.</p><p>For advanced customization of the traversal behaviour, pass a custom <code>walk</code> function of the form <code>(f&#39;, xs) -&gt; ...</code>. This function walks (maps) over <code>xs</code> calling the continuation <code>f&#39;</code> to continue traversal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct Foo; x; y; end

julia&gt; @functor Foo

julia&gt; struct Bar; x; end

julia&gt; @functor Bar

julia&gt; m = Foo(Bar([1,2,3]), (4, 5));

julia&gt; fmap(x -&gt; 2x, m)
Foo(Bar([2, 4, 6]), (8, 10))

julia&gt; fmap(string, m)
Foo(Bar(&quot;[1, 2, 3]&quot;), (&quot;4&quot;, &quot;5&quot;))

julia&gt; fmap(string, m, exclude = v -&gt; v isa Bar)
Foo(&quot;Bar([1, 2, 3])&quot;, (4, 5))

julia&gt; fmap(x -&gt; 2x, m, walk=(f, x) -&gt; x isa Bar ? x : Functors._default_walk(f, x))
Foo(Bar([1, 2, 3]), (8, 10))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Functors.jl/blob/d7bfce830ec3debad4b3b57cfcb0c1522d7e0a83/src/functor.jl#L52-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Functors.children" href="#Functors.children"><code>Functors.children</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">children(x)</code></pre><p>Return the children of <code>x</code> as defined by <a href="@ref"><code>functor</code></a>. Equivalent to <code>functor(x)[1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Functors.jl/blob/d7bfce830ec3debad4b3b57cfcb0c1522d7e0a83/src/functor.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Functors.isleaf" href="#Functors.isleaf"><code>Functors.isleaf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isleaf(x)</code></pre><p>Return true if <code>x</code> has no <a href="#Functors.children"><code>children</code></a> according to <a href="@ref"><code>functor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Functors.jl/blob/d7bfce830ec3debad4b3b57cfcb0c1522d7e0a83/src/functor.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Functors.fcollect" href="#Functors.fcollect"><code>Functors.fcollect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fcollect(x; exclude = v -&gt; false)</code></pre><p>Traverse <code>x</code> by recursing each child of <code>x</code> as defined by <a href="@ref"><code>functor</code></a> and collecting the results into a flat array.</p><p>Doesn&#39;t recurse inside branches rooted at nodes <code>v</code> for which <code>exclude(v) == true</code>. In such cases, the root <code>v</code> is also excluded from the result. By default, <code>exclude</code> always yields <code>false</code>.</p><p>See also <a href="#Functors.children"><code>children</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct Foo; x; y; end

julia&gt; @functor Foo

julia&gt; struct Bar; x; end

julia&gt; @functor Bar

julia&gt; struct NoChildren; x; y; end

julia&gt; m = Foo(Bar([1,2,3]), NoChildren(:a, :b))
Foo(Bar([1, 2, 3]), NoChildren(:a, :b))

julia&gt; fcollect(m)
4-element Vector{Any}:
 Foo(Bar([1, 2, 3]), NoChildren(:a, :b))
 Bar([1, 2, 3])
 [1, 2, 3]
 NoChildren(:a, :b)

julia&gt; fcollect(m, exclude = v -&gt; v isa Bar)
2-element Vector{Any}:
 Foo(Bar([1, 2, 3]), NoChildren(:a, :b))
 NoChildren(:a, :b)

julia&gt; fcollect(m, exclude = v -&gt; Functors.isleaf(v))
2-element Vector{Any}:
 Foo(Bar([1, 2, 3]), NoChildren(:a, :b))
 Bar([1, 2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Functors.jl/blob/d7bfce830ec3debad4b3b57cfcb0c1522d7e0a83/src/functor.jl#L117-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Functors.fmapstructure" href="#Functors.fmapstructure"><code>Functors.fmapstructure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fmapstructure(f, x; exclude = isleaf)</code></pre><p>Like <a href="#Functors.fmap"><code>fmap</code></a>, but doesn&#39;t preserve the type of custom structs. Instead, it returns a (potentially nested) <code>NamedTuple</code>.</p><p>Useful for when the output must not contain custom structs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct Foo; x; y; end

julia&gt; @functor Foo

julia&gt; m = Foo([1,2,3], (4, 5));

julia&gt; fmapstructure(x -&gt; 2x, m)
(x = [2, 4, 6], y = (8, 10))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FluxML/Functors.jl/blob/d7bfce830ec3debad4b3b57cfcb0c1522d7e0a83/src/functor.jl#L96-L114">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Tuesday 13 July 2021 16:00">Tuesday 13 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
